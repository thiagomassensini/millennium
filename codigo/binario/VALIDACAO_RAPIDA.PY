#!/usr/bin/env python3
"""
An√°lise Multirresolu√ß√£o: Detectar harm√¥nicos em TODAS as escalas
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import find_peaks, welch
import sys

print("=" * 80)
print("AN√ÅLISE MULTIRRESOLU√á√ÉO: HARM√îNICOS EM M√öLTIPLAS ESCALAS")
print("=" * 80)
print()

# Par√¢metros
ARQUIVO = sys.argv[1] if len(sys.argv) > 1 else "results.csv"
MAX_LINHAS = int(sys.argv[2]) if len(sys.argv) > 2 else 100000000  # 100M padr√£o

# Escalas para an√°lise (diferentes tamanhos de janela)
ESCALAS = [
    1000,      # Ultra-local
    5000,      # Local
    10000,     # Intermedi√°rio baixo
    50000,     # Intermedi√°rio alto
    100000,    # Global baixo
    500000,    # Global alto
    1000000    # Ultra-global
]

print(f"Arquivo: {ARQUIVO}")
print(f"Linhas: {MAX_LINHAS:,}")
print(f"Escalas: {len(ESCALAS)}")
print()

# Carregar dados
print("Carregando dados...")
df = pd.read_csv(ARQUIVO, nrows=MAX_LINHAS, on_bad_lines='skip')
primos = df.iloc[:, 0].values.astype(np.float64)
print(f"‚úì {len(primos):,} primos carregados")
print()

# Dicion√°rio para armazenar resultados por escala
resultados = {}

# An√°lise para cada escala
for escala_idx, WINDOW_SIZE in enumerate(ESCALAS, 1):
    print(f"Escala {escala_idx}/{len(ESCALAS)}: Janela = {WINDOW_SIZE:,}")
    
    # Calcular densidade local
    n_windows = (len(primos) - WINDOW_SIZE) // (WINDOW_SIZE // 10)
    step = max(1, WINDOW_SIZE // 10)
    
    densidades = []
    for i in range(0, len(primos) - WINDOW_SIZE, step):
        janela = primos[i:i+WINDOW_SIZE]
        span = janela[-1] - janela[0]
        if span > 0:
            dens = WINDOW_SIZE / span
            densidades.append(dens)
    
    densidades = np.array(densidades)
    
    if len(densidades) < 100:
        print(f"  ‚ö† Janela muito grande, pulando")
        continue
    
    # Normalizar
    dens_norm = (densidades - np.mean(densidades)) / np.std(densidades)
    
    # FFT
    N = len(dens_norm)
    yf = fft(dens_norm)
    xf = fftfreq(N, d=1.0)
    
    # S√≥ frequ√™ncias positivas
    mask = xf > 0
    freqs = xf[mask]
    power = np.abs(yf[mask])**2
    
    # Detectar picos
    threshold = np.mean(power) + 3 * np.std(power)
    picos, props = find_peaks(power, height=threshold, distance=5)
    
    # Ordenar por pot√™ncia
    if len(picos) > 0:
        idx_sorted = np.argsort(power[picos])[::-1]
        top_picos = picos[idx_sorted[:20]]  # Top 20
        top_freqs = freqs[top_picos]
        top_powers = power[top_picos]
        
        # Converter frequ√™ncias para "per√≠odos em janelas"
        periodos = 1.0 / top_freqs
        
        # Armazenar
        resultados[WINDOW_SIZE] = {
            'freqs': top_freqs,
            'periodos': periodos,
            'powers': top_powers,
            'n_picos': len(picos)
        }
        
        print(f"  ‚úì {len(picos)} picos detectados")
        print(f"    Top 5 per√≠odos: {periodos[:5]}")
    else:
        print(f"  ‚úó Nenhum pico detectado")
    
    print()

# An√°lise combinada
print("=" * 80)
print("AN√ÅLISE COMBINADA: BUSCA POR HARM√îNICOS PRIMOS")
print("=" * 80)
print()

# Lista de primos para testar (at√© 150)
primos_test = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 
               53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 
               109, 113, 127, 131, 137, 139, 149]

# Para cada primo, verificar em quais escalas aparece
deteccoes = {p: [] for p in primos_test}

for WINDOW_SIZE, res in resultados.items():
    periodos = res['periodos']
    
    for primo in primos_test:
        # Toler√¢ncia: ¬±10%
        matches = np.abs(periodos - primo) / primo < 0.10
        
        if np.any(matches):
            idx_match = np.where(matches)[0][0]
            periodo_obs = periodos[idx_match]
            erro = abs(periodo_obs - primo) / primo
            potencia = res['powers'][idx_match]
            
            deteccoes[primo].append({
                'escala': WINDOW_SIZE,
                'periodo': periodo_obs,
                'erro': erro,
                'potencia': potencia
            })

# Mostrar resultados
print("HARM√îNICOS PRIMOS DETECTADOS:")
print()

primos_detectados = []
for primo in primos_test:
    if len(deteccoes[primo]) > 0:
        primos_detectados.append(primo)
        
        # Calcular estat√≠sticas
        erros = [d['erro'] for d in deteccoes[primo]]
        escalas = [d['escala'] for d in deteccoes[primo]]
        potencias = [d['potencia'] for d in deteccoes[primo]]
        
        erro_medio = np.mean(erros)
        n_escalas = len(escalas)
        potencia_max = np.max(potencias)
        
        print(f"Primo {primo:3d}:")
        print(f"  Detectado em {n_escalas} escalas: {escalas}")
        print(f"  Erro m√©dio: {100*erro_medio:.2f}%")
        print(f"  Pot√™ncia m√°xima: {potencia_max:.2e}")
        print()

print(f"Total de primos detectados: {len(primos_detectados)}")
print(f"Primos: {primos_detectados}")
print()

# Teste especial: Œ±_EM = 1/137
if 137 in primos_detectados:
    print("üèÜ JACKPOT: Primo 137 (1/Œ±_EM) DETECTADO!")
    print()
    print("Detalhes:")
    for det in deteccoes[137]:
        print(f"  Escala {det['escala']:,}: per√≠odo={det['periodo']:.2f}, "
              f"erro={100*det['erro']:.2f}%, pot√™ncia={det['potencia']:.2e}")
    print()
else:
    print("‚ö† Primo 137 (1/Œ±_EM) N√ÉO detectado ainda")
    print("  (pode precisar de dataset maior ou escala diferente)")
    print()

# Visualiza√ß√£o
print("Gerando visualiza√ß√£o...")

fig, axes = plt.subplots(3, 3, figsize=(18, 14))
axes = axes.flatten()

for idx, (WINDOW_SIZE, res) in enumerate(resultados.items()):
    if idx >= 9:
        break
    
    ax = axes[idx]
    
    # Plot espectro
    freqs = res['freqs']
    powers = res['powers']
    periodos = res['periodos']
    
    ax.semilogy(periodos, powers, 'b-', alpha=0.5, linewidth=0.5)
    
    # Marcar primos detectados
    for primo in primos_detectados:
        if primo in [d['periodo'] for d in deteccoes[primo] 
                     if d['escala'] == WINDOW_SIZE]:
            # Encontrar √≠ndice
            idx_primo = np.argmin(np.abs(periodos - primo))
            ax.plot(periodos[idx_primo], powers[idx_primo], 'ro', 
                   markersize=8, label=f'p={primo}')
    
    ax.set_xlabel('Per√≠odo (janelas)')
    ax.set_ylabel('Pot√™ncia')
    ax.set_title(f'Escala: janela={WINDOW_SIZE:,}')
    ax.set_xlim(0, 150)
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

plt.tight_layout()
plt.savefig('harmonicos_multiescala.png', 
            dpi=200, bbox_inches='tight')
print("‚úì Gr√°fico salvo: harmonicos_multiescala.png")
print()

print("=" * 80)
print("CONCLUS√ÉO")
print("=" * 80)
print()
print(f"Primos detectados: {len(primos_detectados)}")
print(f"Range: {min(primos_detectados)} ‚Üí {max(primos_detectados)}")
print()

if 137 in primos_detectados:
    print("‚úì‚úì‚úì CONEX√ÉO COM Œ±_EM CONFIRMADA! ‚úì‚úì‚úì")
else:
    print("‚ö† Primo 137 n√£o detectado (precisa investigar mais)")

print()
print("=" * 80)